# Theory
[https://en.wikipedia.org/wiki/List\_of\_Java\_bytecode\_instructions](https://en.wikipedia.org/wiki/List_of_Java_bytecode_instructions) 

When you execute a compiled java application the class file is read and interpreted by a Java Virtual Machine. This is like a custom virtual CPU that runs inside your existing CPU and follows a different instruction set, the JVM instruction set.

Classes are compiled into .class files, one class per file. These can reference other classes which will be linked by the JVM at runtime. By using a parser such as javap we are able to see the methods and fields present in a class. Each will have a name and a descriptor. The descriptor is a representation of the arguments and return type a method can take, or the type of a field.

Java-Deobfuscator
-----------------

*   If you know what obfuscators were used, skip the next two steps
*   Create `detect.yml` with the following contents. Replace `input.jar` with the name of the input

input: input.jar detect: true

*   Run `java -jar deobfuscator.jar --config detect.yml` to determine the obfuscators used
*   Create `config.yml` with the following contents. Replace `input.jar` with the name of the input

```text-plain
input: input.jar
output: output.jar
transformers:
  - [fully-qualified-name-of-transformer]
  - [fully-qualified-name-of-transformer]
  - [fully-qualified-name-of-transformer]
  - ... etc
```

input: input.jar output: output.jar transformers:  - \[fully-qualified-name-of-transformer\]  - \[fully-qualified-name-of-transformer\]  - \[fully-qualified-name-of-transformer\]  - ... etc

*   Run `java -jar deobfuscator.jar`
*   Re-run the detection if the JAR was not fully deobfuscated - it's possible to layer obfuscations