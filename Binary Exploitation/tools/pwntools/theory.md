# theory
**RELRO** stands for Relocation Read-Only, which makes the global offset table (GOT) read-only after the linker resolves functions to it. The GOT is important for techniques such as the ret-to-libc attack, although this is outside the scope of this room. If you are interested, you can refer to this blog post:  [https://www.redhat.com/en/blog/hardening-elf-binaries-using-relocation-read-only-relro](https://www.redhat.com/en/blog/hardening-elf-binaries-using-relocation-read-only-relro).

**Stack** **canaries** are tokens placed after a stack to detect a stack overflow. These were supposedly named after birds that coal miners brought down to mines to detect noxious fumes. Canaries were sensitive to the fumes, and so if they died, then the miners knew they needed to evacuate. On a less morbid note, stack canaries sit beside the stack in memory (where the program variables are stored), and if there is a stack overflow, then the canary will be corrupted. This allows the program to detect a buffer overflow and shut down. You can read more about stack canaries here: [https://www.sans.org/blog/stack-canaries-gingerly-sidestepping-the-cage/](https://www.sans.org/blog/stack-canaries-gingerly-sidestepping-the-cage/).

**NX** is short for non-executable. If this is enabled, then memory segments can be either writable or executable, but not both. This stops potential attackers from injecting their own malicious code (called shellcode) into the program, because something in a writable segment cannot be executed.  On the vulnerable binary, you may have noticed the extra line **RWX** that indicates that there are segments which can be read, written, and executed. See this Wikipedia article for more details:  [https://en.wikipedia.org/wiki/Executable\_space\_protection](https://en.wikipedia.org/wiki/Executable_space_protection)

**PIE** stands for Position Independent Executable. This loads the program dependencies into random locations, so attacks that rely on memory layout are more difficult to conduct. Here is a good blog about this: [https://access.redhat.com/blogs/766093/posts/1975793](https://access.redhat.com/blogs/766093/posts/1975793)

#### **Address space layout randomization (ASLR)**  
 

Address space layout randomization is a technique involved in preventing exploitation of memory by randomly arranging the address space positions of key data areas of processes and the positions of the stack, heap and libraries.

First of all, we can check if ASLR is turned on in our VM with the command:

```text-plain
cat /proc/sys/kernel/randomize_va_space
```

According to [this](https://securityetalii.es/2013/02/03/how-effective-is-aslr-on-linux-systems/) article, number 2 means full randomization. This means the ASLR is turned on.

But, because of ASLR, we now cannot call the system function because we don't know the address of this function in libc.

And even if we try to find the address of the system function when we run the program, the next time we run it, it'll be a different address. So how do we bypass this? Before telling you how to do that, let me quickly explain the global offset table.

#### **Global Offset Table (GOT)**

The global offset table is a section inside a program that holds addresses of dynamically linked functions.  

Most programs don't include every function they use to reduce binary size. Instead, common functions, like those in libc, are "linked" into the program.  

All dynamic libraries are loaded into memory along with the main program at launch; however, functions aren't mapped to their actual code until they're first called.  

But, after these functions are called for the first time, their real addresses are "saved" in the section of the program called .got.plt.

#### **ASLR Bypass**

So, in theory, we need to leak the address of any function which is in libc and is being used in our binary (so it'll be saved in **.got.plt**).

We need some function that can print values and can take a pointer as an argument. The perfect functions for this are **puts** and **printf**.

So what we can do now is to call puts and, as an argument, pass a pointer to any function that's inside **.got.plt**.

For example: If we call puts and as an argument, we pass the address of the setbuf function inside of .**got.plt** section, then we should have leaked the real address of the sefbuf function inside a libc. And when we have this leak, we can calculate the base address of the libc. **Libc base address => Start of the c library in memory**

And when we have this base address, every time the binary is being run, the address is the same as it would have been when ASLR was turned off,  and from that, we can calculate offsets for every function inside of libc.