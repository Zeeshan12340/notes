# theory
Understanding Format String vulnerability
-----------------------------------------

Normally, when you call printf in a C program, to give it a string with the way you want to format the parameters:

```text-plain
void main() {
  char name[] = "cotonne";
  int age     = 42;
  printf("My name is %s, I'm ~ %u y!", name, age);
}
```

If we look at the assembly code, we can see that those parameters are pushed to the stack:

```text-plain
mov    QWORD PTR [rbp-0x10],rax  # name
mov    DWORD PTR [rbp-0x14],0x2a # 0x2a = 42
...
call   0x1070 <printf@plt>
```

What will happen if you don’t provide enough parameters? Well, `printf` will just try to read data from the stack. So, if we give too many parameters, `printf` just read one element at a time from the stack. We can start to read information from the stack!

Not only we can read information from the stack, but we can also write information almost anywhere! As indicated in the documentation, **the printf parameter %n allows us to write at the address indicated in the stack the number of printed characters. All the trick is then to print the correct number of characters that will be equal to the value we want to write at the provided address.**

So, let’s see what we have:

*   Full RELRO: **RELRO** is for Relocation Read-Only. Linux uses ELF binary format. In this binary, functions called by the program from dependent libraries (like **printf** from **libc**) are dynamically resolved. The first time the function is called, the address is resolved. If your program has a vulnerability that makes it possible to write somewhere in the memory, you can overwrite such address by your own (or replace the address of printf by the address of the function system).
*   Canary: The canary is a special value place on the stack. The value is set when you enter a function and is checked before the function is returned. It prevents us from overwriting the stack. It is a protection against buffer overflows.
*   NX: NX for non-executable. If you change the return address by an address of the stack where you put some code, you would get a SEGFAULT. So, no shellcode on the stack.

So here, we have some problems:

*   We can’t overwrite the Global Offset Table (GOT) due to RELRO
*   We should be careful when we overwrite the stack to not modify the canary value.
*   We can place a shell code in the stack
*   We can’t easily predict address

Well, those protections are not really annoying as we have a convenient vulnerability. With the format string vulnerability, we can read the stack, find precisely interesting values, and overwrite them.

### Making format string to work with pwntools

As explained before, printf will read the stack for extra argument. If we send the string “%p%p”, it will read the first two values from the stack. You can also print the second value from the stack by calling “%2$p”. If we know where is the string we control, we will be able to also set the address that we want to update.

So you can do it by hand (or by writing some code). Just put a recognizable pattern and iter. You should find that the beginning of our string is at position 6:

```text-plain
$ nc exploitme.chall.quel-hacker-es-tu.fr 55555
ABCDEFGH%6$p
ABCDEFGH0x4847464544434241
```

Once done, we need to find useful addresses. If we look at the code, the call stack should be:

```text-plain
Top of stack
... stuff ...
return address to entry function
...
return address of __libc_start_main
...
return address of main function
...
return address of printf
...
```

We will need to find the position to read address we want. Here, I didn’t automate this part. I had to dump the stack with a position going from 1 to 100 and find where are the addresses I was looking for. I run the program locally and debug it with GDB. This way, I was able to know which was the return address and see how I can print it. I did the same with the remote program as some changes might exist between my system and the remote program. I had also to do some math to find some EBP pointer (called later **Y**) which is an address of the stack and calculate the shift to the position of the printf return address.