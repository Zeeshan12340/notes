# Theory
Static vs Dynamic Analysis
--------------------------

 **Static** analysis involves looking at the program as it exists on disk; The program is never executed. 

**Dynamic** analysis involves analyzing the process as it runs. Dynamic analysis is usually preferred unless dealing with malware. Dynamic analysis allows you to see data in memory and how it's being used. Static on the other hand requires you to guess or do detailed reverse engineering to figure it out.

There are three main functionalities that our tools will provide, those are **debugging**, **disassembling**, and **decompiling**. **Disassemblers** will translate the program from its bytes on disk or in memory into its assembly code equivalent and present it in an informative way. 

**Decompilers** are similar to disassemblers except instead of giving us the assembly, it attempts to recreate the code in C/C++. The downside to decompilers is that they can be inaccurate, or lack information. Because of this, if you're using a decompiler it's a good idea to have the disassembled code next to the decompiled code to check for inaccuracies. 

**Debuggers**, alongside disassemblers and decompilers, will allow us to place breakpoints within the program while it's running and analyze registers, memory, statuses, and more. They also allow for changing data in memory while the program is running.

#### Debug Symbols

Debug symbols are extremely helpful and you should use them when you can. Unfortunately, you will usually only have debug symbols for common libraries and rarely for the executable of interest. In addition to that, most reversing tools download symbols for common libraries so if you don't have an internet connection you won't get them.

#### Imports/Exports

These tabs are pretty self-explanatory. The imports tab shows all of the functions imported by the current program from other sources. The exports tab shows all of the functions exposed by the current program. Note that the exports of an executable usually contain only the entry point (where the program starts executing from).

#### Functions

On the left, you can see the Functions window which shows the identified functions for the current program. Depending on what symbols you have access to, you may have more or less functions with actual names. If there are no symbols to identify a function, it will instead be given a generic name such as sub\_140001000 where 140001000 is the address of the function.

#### Prologue

The prologue comes before the body of a function is executed. Not all prologues are the same, but here are three things that can happen and the order they usually happen in.

1.  Volatile registers are saved. If there is shadow space available, and the appropriate compilation options are chosen, the shadow space can be used to hold volatile registers. If there is no room in shadow space then registers are pushed onto the stack.
2.  Space is allocated for the stack frame by subtracting from RSP. The amount subtracted from RSP can be used to determine the number of function parameters.
3.  RSP or RBP may be preserved to be restored later. Since RBP isn't used much for stack purposes in x64 when it gets preserved it's likely _not_ being preserved to keep a stack address safe, rather it's being treated the same as the other volatile registers. In the case that it _is_ being used for stack purposes, you may see something along the lines of `mov RSP, RBP` which moves RSP to where RBP was at, setting up a new stack frame right next to the previous one.

*   basic\_ostream - C++ template for output streams. [More info here](https://en.cppreference.com/w/cpp/io/basic_ostream).
*   char\_traits - Provides some abstraction from basic character and string types.  
     
*   cout - std::cout - Sends text to the console.
*   IDA does this with FLIRT (Fast Library Identification and Recognition Technology) signatures. FLIRT signatures are used to identify standard library functions. The general idea of how they work is they search memory for a chunk of bytes that match a known chunk of bytes in a standard library function. Once a match is found, the function can be named accordingly. You can learn more about FLIRT signatures on the [IDA/Hex-Rays website](https://hex-rays.com/products/ida/tech/flirt/in_depth/). The main() function is a little more difficult since its signature is different for every program. However, IDA can still sometimes find it using some tricks. One commonality of the main() function is that it's called from the program entry point, usually towards the end. There's also usually a test against the return value of main() to determine if anything other than zero was returned. You can use that knowledge to help find the main() function, and there are several other ways as well.

[xlatb](https://www.felixcloutier.com/x86/xlat:xlatb): Apparently, this operation uses the AL register contents (which is the least significant bytes of the least significant half of the RAX registry) to locate an entry in a table in memory, the RBX register to be precise, then it copies the contents of the table back to the AL register, so with this operation we control the AL register.

[bextr](https://www.felixcloutier.com/x86/bextr): From the reference: “Extracts contiguous bits from the first source operand (the second operand) using an index value and length value specified in the second source operand (the third operand)”. We can use this one to control the RBX register (by looking at the full instruction in the image above)

[stosb](https://www.felixcloutier.com/x86/stos:stosb:stosw:stosd:stosq): This operation stores a byte from the AL register (in our case) into RDI.