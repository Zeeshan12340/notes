# egg hunter
Egg Hunter is often used when there is not enough space to place a shellcode that requires lots of bytes. As such, Egg Hunter is a shellcode that will locate the remaining shellcode based on the TAG/EGG that will help to identify the start of the remaining shellcode. This remaining shellcode is usually placed somewhere else in the memory not choose by the memory. Therefore, the same concept applies that we need to hunt for the flag somewhere in the memory which we know the start of the flag is “HTB{“. This can be considered as the TAG/EGG.

Currently, there are tools that help to generate Egg Hunter shellcode such as Pwntool’s _shellcraft.egghunter()_. However, the shellcode generated is too large for this challenge since we only have 60 bytes of space. To use it, stagers are required which is very troublesome. Moreover, I wouldn’t learn how to create an Egg Hunter on my own. If you are interested, I came across this write-up that uses Pwntool’s _shellcraft.egghunter()_ by pwning.tech [here](https://pwning.tech/2021/02/13/hunting/). 

*   [https://medium.com/@chaudharyaditya/](https://medium.com/@chaudharyaditya/slae-0x3-egg-hunter-shellcode-6fe367be2776)
*   [http://www.hick.org/](http://www.hick.org/)

As we access Virtual Address Space (VAS), some of the memory regions are un-allocated and thus it is dangerous to access them as we traverse the memory to search for our flag. Therefore, we can use _access(address, mode)_ which can be called using syscall setting EAX = 0x21. Therefore, the rough algorithm to check for EFAULT (0x2F) error before checking the egg and finally obtaining the string is shown below:

```text-plain
mem_addr = 0x5FFFFFFF

if access(mem_addr, 0) == 0x2f:
    jump_to_next_page()
elif value_at(mem_addr) != egg:
    mem_addr += 1
else:
    print(mem_addr)
```