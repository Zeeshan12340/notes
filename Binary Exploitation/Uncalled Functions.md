# Uncalled Functions
If binary takes some input, then overload it with a large value using `python3 -c “print('A'*1000)”`

If it shows “Segmentation fault”, then BoF can be tried,

little endian format is the reverse of memory address, like for `0x00400567 ,`little endian is `\x67\x05\x40\x00`

With the nature of strcpy, it does not check the length of the data being input so here it’s also possible to overflow the buffer

**We can control where the function returns and change the flow of execution of a program(very cool, right?)**

**PAYLOAD = JUNK(100 bytes) + SHELL CODE (40 bytes) + JUNK (12 byes) + RETURN ADDRESS (6 bytes).**

Uncalled functions
------------------

find memory address of vulnerable function with `info functions` in gdb, then append it to the payload

first convert memory address `0x0000000000400686` to hex using cyberchef to `\x30\x78\x30\x30\x30\x30\x30\x30` and append to the payload like:

`python3 -c “print('A'*1000 + ‘\x30\x78\x30\x30\x30\x30\x30\’)”`

machine registers `esp`, `ebp`, etc.

[https://dhavalkapil.com/blogs/Buffer-Overflow-Exploit/](https://dhavalkapil.com/blogs/Buffer-Overflow-Exploit/) 

![](Uncalled%20Functions/image.png)

**%eip**: The **Instruction pointer register**. It stores the address of the next instruction to be executed. After every instruction execution it’s value is incremented depending upon the size of an instrution.

**%esp**: The **Stack pointer register**. It stores the address of the top of the stack. This is the address of the last element on the stack. The stack grows downward in memory(from higher address values to lower address values). So the `%esp` points to the value in stack at the lowest memory address.

**%ebp**: The **Base pointer register**. The `%ebp` register usually set to `%esp` at the start of the function. This is done to keep tab of function parameters and local variables. Local variables are accessed by subtracting offsets from `%ebp` and function parameters are accessed by adding offsets to it

First of all we would like to see the disassembly of the binary. For that we’ll use `objdump`

```text-plain
objdump -d vuln
```

Exploit
-------

Now we know that 28 bytes are reserved for `buffer`, it is right next to `%ebp`(the Base pointer of the `main` function). Hence the next 4 bytes will store that `%ebp` and the next 4 bytes will store the return address(the address that `%eip` is going to jump to after it completes the function). Now it is pretty obvious how our payload would look like. The first 28+4=32 bytes would be any random characters and the next 4 bytes will be the address of the `secretFunction`

GEF
---

make a seg fault in gef and it should auto-analyze it

use `pattern create 300` to generate a random payload and run binary with it `r <exp`

use `info registers` to see where payload was written, Ideally we want RIP to be overwritten with our payload but it would normally be rbp

use `pattern search 0x6261616161616168` to find where it is written in our registers

Even though we are unable to overwrite RIP, we can calculate the possible offset to RIP based on the offset to RBP. RIP will be overwritten immediately after RBP.

[https://resources.infosecinstitute.com/topic/buffer-overflow-exploitation-case-study/](https://resources.infosecinstitute.com/topic/buffer-overflow-exploitation-case-study/) 

you can overwrite RIP but when you do your search for offset you check $rsp